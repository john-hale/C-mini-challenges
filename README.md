# C-mini-challenges
C mini challenges for HPC class
For the following Mini-Challenges, you may use the Ubuntu VM set up for you. You will need to install gcc (and maybe valgrind), e.g., "sudo apt install gcc." The Cyber VM Infrastructure Notes should guide you on how to get started with the VMs.


Use the GitHub assignment link here:


I recommend creating a SSH key for the VM and associating it with your GitHub account.  It takes a little bit of work but should be worth it in the long run. Guidance on how SSH key generation and GitHub association - generated by Claude and vetted by me - is available in the course contents section for this class.


And now, on to the Mini-Challenges:

Print “Hello, <NAME>” where NAME is input from the keyboard.
    
Implement Archimedes algorithm to estimate pi for inscribed/circumscribed polygons with n sides, up to 100, doubling n at each step, and time it.
    
Implement matrix – vector multiplication. Read in the following text file (mv.txt) which contains the matrix and vector to be multiplied. Print your answer to the screen and time the computation. The format of mv.txt is: line 1 contains numrows, numcols. The next numrows contains the rows of the matrix, each with numcols integer values. The next line contains the length of the vector. The next line contains the vector of that length.
    
Compare the speed of *,/,sqrt, sin operations/functions.
    
Use the attached code snippets as a basis for comparing the performance of row-major vs. column major computations. One snippet uses a static allocation for the array, the other allocates the array dynamically. Do a little experimentation with each approach. Vary the size of the square array from 128 X 128 on up, doubling it in size each time. Chart your results. Is there a difference in performance or behavior between static and dynamic? Between row-major and column-major? In terms of the latter, valgrind has been installed on your Linux VM, and its cachegrind tool facility may help provide some insights. Do some OSINT research to learn about valgrind....
    
Write a program that accepts a string input from stdio and sends it to a function that transforms it according a transposition function passed in to it as an argument.  The function will print out the string, transform it, and then print out the result. The transposition function, you can assume, simply shuffles the existing characters in the string.  Build a transposition function that reverses the string and apply it.  Where appropriate and possible, use dynamic allocation and pointer arithmetic to get the job done.


Submit:

A link to your code for each mini-challenge from our Github classroom.
Also, submit a PDF with your output (screenshots will suffice), and with responses to the following:


1. For the Hello Name challenge:

a. Did you try passing your name as an argument from the command line or did you use scanf? Why?

b. How did you manage or allocate the strings? (Static or dynamic)


2. For Archimedes algorithm

a. How did you time your program?

b. Were there any issues with precision and/or convergence that you noticed?


3. For Matrix-vector multiplication

a. How did you allocate and access your matrix?

b. Were there any challenges in reading in the file?

c. Was there anything special about the actual computation?

d. What was your strategy for timing?


4. For measuring the speed of arithmetic computations

a. What was your timing strategy?

b. Are all arithmetic operations created equal?


5. For the row-major/column-major exercise

a. What did you observe about differences in program behavior in static vs dynamic allocation of arrays, and how do you explain it?

b. What did you observe about differences in program behavior in row-major vs. column major computations and how do you explain it?


6. For the string transform problem

a. What were some alternative implementation strategies could you entertain here?

b. What programming hazards/pitfalls should be considered in your general approach?
